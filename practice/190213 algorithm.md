# 190213 algorithm

## 1. stack

```box
데이터가 저장되는 위치

code
data(전역변수)
heap(참조형)-list,str (여러 함수에서 사용이 가능하다=주소를 이용하기 때문)
stack(지역변수)-일반변수 , 함수가 여기에 저장이 된다. (각 각 저장한다.)
```



1. 자료 구조

   - stack의 경우에는 선형구조라고 한다. 선형구조란, 1:1로 데이터가 연결되는 경우를 의미한다. 전체적으로 보면 자료 구조는 아래와 같다.

   ​	(1) 선형구조 : list, stack, queue, deque

   ​	(2) 비선형구조 : tree, graph

   ​		tree > 1:N 구조 이다

   ​		graph > N:N 구조 이다(순환), tree는 graph에 포함된다

​	

2. 재귀 관련 

   - factorial을 구하는 순서를 생각해보면 이해하기 쉽다. f(4)를 구하기 위해서는 f(3)을 구해야 하고 f(3)을 구하려면 f(2)를 구해야하는 느낌처럼, f(4)가 먼저 stack에 들어가고 그 다음에 f(3)이, 그리고 f(2)가 필요로 하며, 결과적으로 적은 숫자의 factorial이 구해져야 pop을 하고, 최종적으로 원하는 값의 factorial을 구할 수 있게 된다. 

   - 하지만 중복호출이 되는 경우에는 복잡도가 높아진다는 단점이 있다. 이를 해결하기 위해 어떤 과정이 필요하지만, 일단 간단한 개요를 먼저 다루도록 한다.

   - 필요한 구성요소 : basis, inductive

     (1) basis (기본) : 멈추는 부분. ex, !에서의 f(1). (일종의 초기값)

     (2) inductive (유도) : 자기호출 (일종의 점화식)

   - 예시

     ```python
     def fact(num):
         if num==1:
             return 1
         else:
             return num * fact(num-1)
     ```


3. memoization
4. DP(dynamic Programming)

5. DFS (오늘 중점적으로 한 것)

   - 모든 자료를 빠짐없이. 중복은 피해야 한다. 지나쳤던 곳을 표시하는 기능이 필요. 스택으로서 구현화

   - DFS 관련된 것은 04_파이썬기본__stack1___DFS.기본 참고하도록 한다.

   - 여기에서 나온 연습문제1 를 풀기 위해서는 인접행렬을 먼저 만들어야 한다.

   - 원래 방향성, 가중치도 따져야 한다. 경로가 있으면 1, 없으면 0 으로 2차원 배열로 만든다.





