# 190403 algorithm

## 1. Stack, Queue

queue 에 자료구조가 많이 들어갈 때에는

배열로 append, pop을 시키면, stack overflow 가 나올 수 있다. pop 자체의 복잡도가 N 이므로,

이럴 때에는 stack, queue를 c 스타일로 짜면 된다.

```python
Q = [0] * N**2
rear = -1
front = -1
def enQueue():
    global rear
    rear += 1
    Q[rear] = item
def deQueue():
    global front
    front += 1
    item = Q[front]
def empty():
    global rear, front
    if rear == front:
        return True
    return False
```



## 2. 서로소 집합들 ( Disjoint-Sets )

### 2-1. 개념

( A반_SW문제해결응용1_296/341 )

원소 중에 대표자를 뽑겠다??

x, y는 원소 이다.

- Make-Set(x) : 자기 자신(x)을 대표자로 하겠다.
- Find-Set(x) : x 가 속해있는 집단 중 대표자는 누구인가 찾는 함수.
- Union(x, y) : 두 개를 합치면 대표자 하나로 되어야 함. 대표자 쪽은 0번 인덱스로 가게끔 더하면 됨.

> 1차원 배열로 구현가능함.



### 2-2. 문제 : 최소신장트리(MST)

- 신장 트리 : N 개의 정점(노드), N-1 개의 간선 으로 이루어진 트리

- 최소신장트리 : 간선들의 가중치의 합이 최소인 시장 트리

  = 그래프에서 모든 점을 체크하는 최소 비용 문제 (간선의 합을 최소로 쓰는 방법)

ex, 송유관 건설



### 2-3. 알고리즘 (alog/190403practice)

1. 간선의 합 기준 ( 모든 노드를 지나는 간선들의 최소합)

- Prim :초기에 모든 점의 가중치를 무한으로 치고 , 시작점에서 갈 수 있는 방법에 대해 가중치가 최소인 점을 선택하고 , 지속적으로 최소가중치를 향해 누적.

  > 2차 배열(인접행렬), D (가중치), PI (대표자) , visit(방문 유무)
  >
  > 최소신장트리_PRIM(MST).py

  - 시작점에 관계 없이 답이 하나이다.
  - 단 순환되어서는 안됨. 

- KRUSKAL : 정리 필요

  > 2차 배열(인접행렬이 아닌, 인접 데이터와 가중치 담은 배열), PI (대표자)
  >
  > 최소신장트리_KRUSKAL(MST).py

  - prim과 목적은 같다. 조금 더 간단해보인다.
  - 간선을 오름차순으로 정렬한 후, 순환되지 않게 간선들을 잇는다
  - 간선들의 갯수가 노드-1 일 때 종료한다.



2. 시작 노드에서 도착 노드까지의 최단거리 (모든 노드를 지나는 것이 아님, 시작-목적지 까지의 최소거리)

- dijkstra (다익스트라) : 시작점이 존재하고, 시작점에서 각 노드로 갈 수 있는 최소거리를 구할 수 있게 된다. 단, 경로는 나타나지 않고, 결과값(최소이동거리)만 알 수 있다.

  > 2차 배열(인접행렬), D (가중치), visit(방문 유무)
  >
  > /5251_최소이동거리

  - 가지치기를 적용할 수 있다(bfs)
  - 복잡도는 n**2

  - 시작점에서 모든 도착점까지 가장 짧은 길이를 찾는 알고리즘이다.

- DP적 접근(Floyd 알고리즘) : brute-force 접근 방법

  > 2차 배열(인접행렬 에 대한 조작 필요 : 길이 없는 곳은 큰 수, i=j 인덱스는 0 값)

  - 복잡도는 n**3 
  - 간편하게 구현가능하지만, 복잡도가 높으므로, bfs+dijkstra 를 할 수 있도록 노력해보자.

  - a 에서 b 로 갈 때 경유점을 1~n 다 지나쳤을 때 뭐가 최소인지 for문으로 비교적용하는 것.



전체적으로 그림으로 그려가면서, 과정과 의미 를 이해한 다음, 무엇이 필요한지 생각해보는 것이 좋을 것 같다.